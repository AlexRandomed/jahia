package org.jahia.services.content;

import javax.jcr.RepositoryException;
import javax.jcr.Workspace;
import javax.jcr.observation.*;
import javax.jcr.observation.EventListener;
import java.util.*;

/**
 * Observation manager implementation
 *
 * Execute listener synchronously after session.save()
 *
 */
public class JCRObservationManager implements ObservationManager {

    private static ThreadLocal<JCRSessionWrapper> currentSession = new ThreadLocal<JCRSessionWrapper>();
    private static ThreadLocal<Boolean> inEvents = new ThreadLocal<Boolean>();
    private static ThreadLocal<Map<JCRSessionWrapper,List<Event>>> events = new ThreadLocal<Map<JCRSessionWrapper,List<Event>>>();
    private static List<EventConsumer> listeners = new ArrayList<EventConsumer>();

    private JCRWorkspaceWrapper ws;

    public JCRObservationManager(JCRWorkspaceWrapper ws) {
        this.ws = ws;
    }

    /**
     * Adds an event listener that listens for the specified <code>eventTypes</code> (a combination of one or more
     * event types encoded as a bit mask value).
     * <p/>
     * The set of events can be filtered by specifying restrictions based on characteristics of the node associated
     * with the event. In the case of  event types <code>NODE_ADDED</code> and <code>NODE_REMOVED</code>, the node
     * associated with an event is the node at (or formerly at) the path returned by <code>Event.getPath</code>.
     * In the case of  event types <code>PROPERTY_ADDED</code>,  <code>PROPERTY_REMOVED</code> and
     * <code>PROPERTY_CHANGED</code>, the node associated with an event is the parent node of the property at
     * (or formerly at) the path returned by <code>Event.getPath</code>:
     * <ul>
     * <li>
     * <code>absPath</code>, <code>isDeep</code>: Only events whose associated node is at
     * <code>absPath</code> (or within its subtree, if <code>isDeep</code> is <code>true</code>) will be received.
     * It is permissible to register a listener for a path where no node currently exists.
     * </li>
     * <li>
     * <code>uuid</code>: Only events whose associated node has one of the UUIDs in this list will be
     * received. If his parameter is <code>null</code> then no UUID-related restriction is placed on events
     * received.
     * </li>
     * <li>
     * <code>nodeTypeName</code>: Only events whose associated node has one of the node types
     * (or a subtype of one of the node types) in this list will be received. If his parameter is
     * <code>null</code> then no node type-related restriction is placed on events received.
     * </li>
     * </ul>
     * The restrictions are "ANDed" together. In other words, for a particular node to be "listened to" it must meet all the restrictions.
     * <p/>
     * Additionally, if <code>noLocal</code> is <code>true</code>, then events generated by the session through which
     * the listener was registered are ignored. Otherwise, they are not ignored.
     * <p/>
     * The filters of an already-registered <code>EventListener</code> can be changed at runtime by re-registering the
     * same <code>EventListener</code> object (i.e. the same actual Java object) with a new set of filter arguments.
     * The implementation must ensure that no events are lost during the changeover.
     *
     * @param listener     an {@link javax.jcr.observation.EventListener} object.
     * @param eventTypes   A combination of one or more event type constants encoded as a bitmask.
     * @param absPath      an absolute path.
     * @param isDeep       a <code>boolean</code>.
     * @param uuid         array of UUIDs.
     * @param nodeTypeName array of node type names.
     * @param noLocal      a <code>boolean</code>.
     * @throws javax.jcr.RepositoryException If an error occurs.
     */
    public void addEventListener(EventListener listener, int eventTypes, String absPath, boolean isDeep, String[] uuid, String[] nodeTypeName, boolean noLocal) throws RepositoryException {
        listeners.add(new EventConsumer(ws.getSession(), listener,  eventTypes, absPath, isDeep, uuid, nodeTypeName, noLocal));
    }

    /**
     * Deregisters an event listener.
     * <p/>
     * A listener may be deregistered while it is being executed. The
     * deregistration method will block until the listener has completed
     * executing. An exception to this rule is a listener which deregisters
     * itself from within the <code>onEvent</code> method. In this case, the
     * deregistration method returns immediately, but deregistration will
     * effectively be delayed until the listener completes.
     *
     * @param listener The listener to deregister.
     * @throws javax.jcr.RepositoryException If an error occurs.
     */
    public void removeEventListener(EventListener listener) throws RepositoryException {
        EventConsumer e = null;
        for (EventConsumer eventConsumer : listeners) {
            if (eventConsumer.listener == listener) {
                e = eventConsumer;
                break;
            }
        }
        if (e != null) {
            listeners.remove(e);
        }
    }

    /**
     * Returns all event listeners that have been registered through this session.
     * If no listeners have been registered, an empty iterator is returned.
     *
     * @return an <code>EventListenerIterator</code>.
     * @throws javax.jcr.RepositoryException
     */
    public EventListenerIterator getRegisteredEventListeners() throws RepositoryException {
        return new EventListenerIteratorImpl(listeners.iterator(), listeners.size());
    }

    public void setUserData(String userData) throws RepositoryException {

    }

    public EventJournal getEventJournal() throws RepositoryException {
        return null;
    }

    public EventJournal getEventJournal(int i, String s, boolean b, String[] strings, String[] strings1) throws RepositoryException {
        return null;
    }

    public static void addEvent(Event event) {
        Map<JCRSessionWrapper, List<Event>> map = events.get();
        if (map == null) {
            events.set(new HashMap<JCRSessionWrapper, List<Event>>());
        }
        map = events.get();

        JCRSessionWrapper session = currentSession.get();
        if (session != null && !session.isEventsDisabled()) {
            if (!map.containsKey(session)) {
                map.put(session, new ArrayList<Event>());
            }
            List<Event> list = map.get(session);

            list.add(event);
        }
    }

    public static void setCurrentSession(JCRSessionWrapper session) {
        currentSession.set(session);
    }

    public static void consume(JCRSessionWrapper session) {
        Map<JCRSessionWrapper,List<Event>> map = events.get();
        if (inEvents.get() == null) {
            events.set(null);
            currentSession.set(null);            
            inEvents.set(Boolean.TRUE);
            try {
                if (map != null && map.containsKey(session)) {
                    List<Event> list = map.get(session);
                    for (EventConsumer consumer : listeners) {
                        if (consumer.session.getWorkspace().getName().equals(session.getWorkspace().getName())) {
                            List<Event> filteredEvents = new ArrayList<Event>();
                            for (Event event : list) {
                                if ((consumer.eventTypes & event.getType()) != 0) {
                                    filteredEvents.add(event);
                                }
                            }
                            consumer.listener.onEvent(new EventIteratorImpl(filteredEvents.iterator(), filteredEvents.size()));
                        }
                    }
                }
            } finally {
                inEvents.set(null);
            }            
        }
    }

    class EventConsumer {
        private JCRSessionWrapper session;
        private EventListener listener;
        private int eventTypes;
        private String absPath;
        private boolean isDeep;
        private String[] uuid;
        private String[] nodeTypeName;
        private boolean noLocal;

        EventConsumer(JCRSessionWrapper session, EventListener listener, int eventTypes, String absPath, boolean deep, String[] uuid, String[] nodeTypeName, boolean noLocal) {
            this.session = session;
            this.listener = listener;
            this.eventTypes = eventTypes;
            this.absPath = absPath;
            isDeep = deep;
            this.uuid = uuid;
            this.nodeTypeName = nodeTypeName;
            this.noLocal = noLocal;
        }
    }

    static class EventIteratorImpl extends RangeIteratorImpl implements EventIterator {
        EventIteratorImpl(Iterator iterator, long size) {
            super(iterator, size);
        }

        /**
         * Returns the next <code>Event</code> in the iteration.
         *
         * @return the next <code>Event</code> in the iteration.
         * @throws java.util.NoSuchElementException
         *          if iteration has no more <code>Event</code>s.
         */
        public Event nextEvent() {
            return (Event) next();
        }
    }

    class EventListenerIteratorImpl extends RangeIteratorImpl implements EventListenerIterator {
        EventListenerIteratorImpl(Iterator iterator, long size) {
            super(iterator, size);
        }

        /**
         * Returns the next <code>EventListener</code> in the iteration.
         *
         * @return the next <code>EventListener</code> in the iteration.
         * @throws java.util.NoSuchElementException
         *          if iteration has no more <code>EventListener</code>s.
         */
        public EventListener nextEventListener() {
            return ((EventConsumer) next()).listener;
        }
    }
}


