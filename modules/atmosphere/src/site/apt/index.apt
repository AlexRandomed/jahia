How-to use atmosphere framework within Jahia

 In atmosphere you declare broadcasters that will broadcast messages to all networks connected to them.

 There is two side for each atmosphere module you will code, first the server part that will broadcast messages, and the
 client side that will subscribe to those broadcasts.

 For more information about {{{https://github.com/Atmosphere/atmosphere/wiki}Atmosphere Framework}}

* Server Side

  Using atmosphere and javax RESTful annotations you can easily declare a broadcaster in your module.

+-------------------------
 @Path("/alert/{channel}")
 @Produces("text/plain;charset=UTF-8")
 public class AlertChannelPublisherSubscriber {

      private @PathParam("channel")
      Broadcaster topic;

      @GET
      @Suspend(resumeOnBroadcast = true, outputComments = false)
      public Broadcastable subscribe() {
          return new Broadcastable(topic);
      }

      @POST
      @Broadcast
      public Broadcastable publish(@FormParam("message") String message) {
          return new Broadcastable(message+"\n", "", topic);
      }
 }
+-------------------------

 Using the annotations you can define how your broadcaster will behave, you can define sub paths with different
 configuration for the same broadcaster.

 <<Line 1>> @Path : The Path annotation is used to tell Jersey to map all the request "/" to this resource. That means a
 request to http://127.0.0.1:8080/ will be delivered to that resource (or that class will be executed).

 <<Line 2>> @Produces : Defines the media type(s) that the methods of a resource class or MessageBodyWriter can produce.

 <<Line 5>> @PathParam : Binds the value of a URI template parameter or a path segment containing the template parameter
 to a resource method parameter, resource class field, or resource class bean property.

 <<Line 8>>  @GET : Indicates that the annotated method responds to HTTP GET requests

 <<Line 9>>  @Suspend : The Atmosphere @Suspend annotation is used to tell the framework to suspend the connection, or,
 in other word, to not commit the response and let the connection open for write operation. Suspending a connection with
 HTTP means leaving not writing back anything where with WebSocket it means execute the handshake operation and let the
 connection open. Here we are telling Atmosphere to suspend the connection indefinitely (no times out). The connection
 life cycle will be transparently handled by Atmosphere

 <<Line 14>> @POST : Indicates that the annotated method responds to HTTP POST requests

 <<Line 15>> @Broadcast : The @Broadcast is used to tell the framework to broadcast events to the set of suspended
 connections. The writeEntity = false attribute is used here to tell the framework to not write anything back to the
 client, and instead let the broadcast operation to do it. The broadcast operation will be handled by a Broadcaster.

 No need to declare anything in spring or other config files. Now you can connect to this broadcaster with a client, like the
 jquery atmosphere client. See
 {{{https://github.com/Atmosphere/atmosphere/wiki/Getting-Started-with-The-Atmosphere-Framework-and-WebSocket}
  Getting Started with The Atmosphere Framework}} and
 {{{http://docs.oracle.com/javaee/6/api/javax/ws/rs/package-summary.html}High-level interfaces and annotations used to
 create RESTful service resources}} for more details

* Client side

 Using the jquery atmosphere client to subscribe/publish to a broadcaster

+-------------------------
<template:addResources type="javascript" resources="jquery.min.js,jquery.atmosphere.js,jquery.jgrowl.js"/>

    <c:set var="channelName" value="${currentNode.properties['name'].string}"/>
    <script type="text/javascript">
        var connectedAbsoluteEndpoint = new Array();

        function callbackAbsolute(response) {
            // Websocket events.
            $.atmosphere.log('info', ["response.state: " + response.state]);
            $.atmosphere.log('info', ["response.transport: " + response.transport]);
            $.atmosphere.log('info', ["response.status: " + response.status]);

            detectedTransport = response.transport;
            if (response.transport != 'polling' && response.state != 'connected' && response.state != 'closed') {
                $.atmosphere.log('info', ["response.responseBody: " + response.responseBody]);
                if (response.status == 200) {
                    var data = response.responseBody;
                    if (data.length > 0) {
                        $.jGrowl(data,{sticky:true});
                    }
                }
            }
        }

        $(document).ready(function() {
            $.atmosphere.unsubscribe();
            var subscribe = $.atmosphere.subscribe("${url.server}${url.context}/atmosphere/alert/${channelName}", callbackAbsolute,
                    $.atmosphere.request = { transport: "websocket" });
            connectedAbsoluteEndpoint["${channelName}"] = subscribe;
        });
    </script>
+-------------------------

 $.atmosphere.subscribe is the way to subscribe to a broadcaster, this method returns a subscriber object that you need
  to kept reference of if you want to publish messages to this broadcaster.

  Here we will see how to reuse this subscriber object to publish a message to everyone listening to this broadcast.

+--------------------------
  <c:set var="channelName" value="${currentNode.properties['name'].string}"/>
      <template:addResources type="javascript" resources="jquery.min.js,jquery.atmosphere.js"/>

      <div id='sendMessage'>
          <input id='phrase' type='text'/>
          <input id="send_message" class='button' name='Publish' value='Publish Message to ${channelName}' type="submit"/>
      </div>

      <script type="text/javascript">
          $("#send_message").click(function () {
              connectedAbsoluteEndpoint["${channelName}"].push({data:'message=' + $("#phrase").val()});
          });
      </script>
+--------------------------

  Here we use the object we have previously saved when subscribing to our broadcaster <connectedAbsoluteEndpoint["${channelName}"]>
  and call the method push using the param name we have defined in our annotations for the message <@FormParam("message")>

* Server side broadcasting

 Using atmopshere broadcasterFactory you can easily lookup for a broadcaster by its id (name). Then sent a message to all
 listeners.

+----------------------------
 private void broadcast(String broadcasterID, String message, boolean createIfNull) {
        final BroadcasterFactory broadcasterFactory = BroadcasterFactory.getDefault();
        if (broadcasterFactory != null) {
            Broadcaster broadcaster = broadcasterFactory.lookup(broadcasterID, createIfNull);
            if (broadcaster != null) {
                broadcaster.broadcast(message);
            }
        }
    }
+----------------------------

 For example in the components provided by Jahia we sent json messages that can be displayed by jgrowl as popup messages.
